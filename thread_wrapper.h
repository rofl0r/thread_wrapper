#ifndef THREAD_WRAPPER_H
#define THREAD_WRAPPER_H

#include <pthread.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* thanks to mathias gaunard for BOOST_PP advice */
#include <boost/preprocessor/array/elem.hpp>
#include <boost/preprocessor/repetition.hpp>



//RcB: LINK "-lpthread"

#if 0

/* example of what will be generated by the macros */

typedef struct {
	pthread_attr_t attr;
	pthread_t thread;
	int result;
	int x; 
	void* y; 
	int z;
} worker_func_thread_data;

static void* worker_func_child_thread(void* data) {
	worker_func_thread_data *child_thread_data = data;
	child_thread_data->result = worker_func(child_thread_data->x, child_thread_data->y, child_thread_data->z);
	return NULL;
}
/* returns NULL on success, otherwise error message string 
 * if an error happens, the pthread_attr_t member of ti gets
 * automatically cleaned up. */
static const char* worker_func_thread_launcher(size_t stacksize, void ** vti, int x, void* y, int z) {
	const char* errmsg = NULL;
	worker_func_thread_data** ti = vti;
	worker_func_thread_data* p;
	p = *ti = calloc(1, sizeof(worker_func_thread_data));
	if(!p) {
		errmsg = "OOM";
		goto ret;
	}
	p->x = x;
	p->y = y;
	p->z = z;
	
	if((errno = pthread_attr_init(&p->attr))) {
		errmsg = "pthread_attr_init";
		goto err;
	}

	if((errno = pthread_attr_setstacksize(&p->attr, stacksize))) {
		errmsg = "pthread_attr_setstacksize";
		goto pt_err_attr;
	}
	if((errno = pthread_create(&p->thread, &p->attr, worker_func_child_thread, *ti))) {
		errmsg = "pthread_create";
		goto pt_err_attr;
	}
	
	ret:
	return errmsg;
	
	pt_err_attr:
	pthread_attr_destroy(&p->attr);
	err:
	free(p);
	(*ti) = NULL;
	goto ret;
}

static const char* worker_func_wait(int* result, void** vti) {
	worker_func_thread_data** ti = vti;
	worker_func_thread_data* p = *ti;
	const char* errmsg = NULL;

	if((errno = pthread_join(p->thread, NULL))) {
		errmsg = "pthread_join";
		pthread_attr_destroy(&p->attr);
		goto ret;
	}
	if((errno = pthread_attr_destroy(&p->attr))) {
		errmsg = "pthread_attr_destroy";
	}
	*result = p->result;
	ret:
	free(p);
	*ti = NULL;
	return errmsg;
}
#endif

#define THREAD_WRAPPER_EXPAND_FUNCTION_ARGS(z, n, data) child_thread_data->BOOST_PP_ARRAY_ELEM(n,data)
#define THREAD_WRAPPER_ASSIGN(z, n, data) p->BOOST_PP_ARRAY_ELEM(n,data) = BOOST_PP_ARRAY_ELEM(n,data);
#define THREAD_WRAPPER_EXPAND_SEMICOLON(z, n, data) BOOST_PP_ARRAY_ELEM(n,data);
#define THREAD_WRAPPER(returntype, function, argcount, types_and_args, args) \
typedef struct { \
	pthread_attr_t attr; \
	pthread_t thread; \
	returntype result; \
	BOOST_PP_REPEAT(argcount, THREAD_WRAPPER_EXPAND_SEMICOLON, (argcount, types_and_args)) \
} function ## _thread_data; \
static void* function ## _child_thread(void* data) { \
	function ## _thread_data *child_thread_data = data; \
	child_thread_data->result = function(BOOST_PP_ENUM(argcount, THREAD_WRAPPER_EXPAND_FUNCTION_ARGS, (argcount, args))); \
	return NULL; \
}\
static const char* function ## _thread_launcher(size_t stacksize, void ** vti, BOOST_PP_TUPLE_REM_I(argcount) types_and_args) { \
	const char* errmsg = NULL; \
	function ## _thread_data** ti = (function ## _thread_data**) vti; \
	function ## _thread_data* p; \
	p = *ti = calloc(1, sizeof(function ## _thread_data)); \
	if(!p) { errmsg = "OOM"; goto ret; } \
	BOOST_PP_REPEAT(argcount, THREAD_WRAPPER_ASSIGN, (argcount, args)) \
	if((errno = pthread_attr_init(&p->attr))) { \
		errmsg = "pthread_attr_init"; \
		goto err; \
	} \
	\
	if((errno = pthread_attr_setstacksize(&p->attr, stacksize))) { \
		errmsg = "pthread_attr_setstacksize"; \
		goto pt_err_attr; \
	}\
	if((errno = pthread_create(&p->thread, &p->attr, function ## _child_thread, p))) { \
		errmsg = "pthread_create"; \
		goto pt_err_attr; \
	} \
	 \
	ret: \
	return errmsg; \
	 \
	pt_err_attr: \
	pthread_attr_destroy(&p->attr); \
	err: \
	free(p); \
	*ti = NULL; \
	goto ret; \
} \
\
static const char* function ## _wait(returntype * result, void** vti) { \
	function ## _thread_data** ti = (function ## _thread_data**) vti; \
	function ## _thread_data* p = *ti; \
	const char* errmsg = NULL; \
	\
	if((errno = pthread_join(p->thread, NULL))) { \
		errmsg = "pthread_join"; \
		pthread_attr_destroy(&p->attr); \
		goto ret; \
	} \
	if((errno = pthread_attr_destroy(&p->attr))) { \
		errmsg = "pthread_attr_destroy"; \
	} \
	*result = p->result; \
	ret: \
	free(p); \
	*ti = NULL; \
	return errmsg; \
}

#define THREAD_LAUNCH(stacksize, name, function, argcount, args) \
function ## _thread_launcher(stacksize, &(name), BOOST_PP_TUPLE_REM_I(argcount) args )


#define THREAD_WAIT(presult, name, function) \
	function ## _wait(presult, &(name))


#endif
